---
title: 'Assembly interpreter inside of TypeScript''s type system'
createDate: '2022-09-12T22:00:00.000Z'
updateDate: '2022-09-16T18:39:19.991Z'
thumbnail: https://images.unsplash.com/photo-1655720845034-b8f615109b5b?ixlib=rb-4.0.3&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2064&q=80
description: ''
tags:
  - typescript
  - compiler theory
---

So, don't freak out, but TypeScript's type system is advanced enough to be able to **host entire programming languages inside of it**, using template literal types and conditional types, among other techniques.

This has been done before, to varying degrees of insanity. Check out [ts-sql](https://github.com/codemix/ts-sql) and [typefuck](https://github.com/susisu/typefuck).

As this is some mind-bogglingly crazy stuff, I had to start by testing if it's even possible for more complex languages. At first, I tried creating a full programming language similar to Lua and Python. This was mostly successful but due to the fact that it required an operator precedence parser, it got complicated and slow pretty fast.

I decided to revisit that later and pursue something with a simpler grammar first. I settled on a dialect of Assembly inspired by RISC and ARMv7.

And thus, [ts-asm](https://github.com/judehunter/ts-asm) was born.

Don't worry if you're not familiar with Assembly though. At it's core, it's a relatively simple language of statements that instruct the processor which atomic operation to perform next, in a linear fashion. The processor has an array of registers, which store binary numbers that the processor can do calculations on. It can also read from and write to memory. Here's an example of a simple Assembly program:

```js
// put the number 2 (10 in binary) in register 0
MOV r0, #00000010
// put the number 3 in register 1
MOV r1, #00000011
// add the numbers in registers 0 and 1
// and put the result in register 2
ADD r2, r0, r1
// subtract the number 1 from the number in register 2
// and put the result in register 2 again
SUB r2, r2, #00000001
```

# Intro
{/* As mentioned, the dialact of Assembly I created is a simple one based on ARM. */}

My artificial TypeScript processor will operate on 8-bit binary numbers. [Attempts have been made](https://itnext.io/implementing-arithmetic-within-typescripts-type-system-a1ef140a6f6f) to simulate arithmetic operations on decimal numbers by generating tuples. This is not a viable option for larger numbers though, since for any number `N`, it recursively creates `N` type instances.

Regardless, that's the way actual processors work. It should be able to perform bitwise logic on the numbers stored in the registers.

If you're familiar with [String Literal Types](https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types) and [Template Literal Types](https://www.typescriptlang.org/docs/handbook/2/template-literal-types.html), you know that TypeScript treats string constants as their own types and allows us to transform them to a surprising degree.

For instance, we can make a function that only accepts these particular strings:
```ts
type VerticalDirection = 'north' | 'south';
type HorizontalDirection = 'west' | 'east';
type Direction = VerticalDirection | HorizontalDirection;

const foo = (direction: Direction) => {};

foo('north'); // OK!
foo('up'); // ERR!
```

We can also generate new literal types by combining them like so:
```ts
type MixedDirection =
  | Direction
  | `${VerticalDirection}-${HorizontalDirection}`;

// the generated type is equivalent to:
type MixedDirection =
  | 'north' | 'south' | 'west' | 'east'
  | 'north-west' | 'north-east'
  | 'south-west' | 'south-east';
```

We can then use [Conditional Types](https://www.typescriptlang.org/docs/handbook/2/conditional-types.html) to transform types based on their value.
```ts
// creates a string literal type that's the first
// character of the T string
type FirstCharacter<T> =
  T extends `${infer First}${string}` ? First : never;

FirstCharacter<'abcdef'> // 'a'

// same thing, just with the last character.
// due to how these template types work,
// we need to use recursive types to achieve this.
type LastCharacter<T> =
  T extends `${string}${infer Rest}`
    ? Rest extends ''
      ? T
      : LastCharacter<Rest>
    : never;

LastCharacter<'abcdef'> // 'f'
```

All that to say, we can replicate exactly what a real processor does by manipulating strings of ones and zeros.

As a proof of concept, I began prototyping a Binary Adder, i.e. a circuit that given two input bits, adds them together, and spits out the result, as well as the carry.

## Adder
While a real processor performs this operation using multiple logic gates, we can instead define a table of input and output values for our adder circuit and implement it using all the aforementioned techniques.

- `A` and `B` represent our input bits.
- `C` represents our input carry bit. This is used so that we can chain adders to create the Full Adder. So the adder actually adds three bits.
- `Result` represents our result output bit.
- `Carry` represents the carry output bit, which we can pipe into another adder.

<center>
| A | B | C | Result | Carry |
|---|---|---|---|---|
| 0 | 0 | 0 | 0 | 0 |
| 0 | 0 | 1 | 1 | 0 |
| 0 | 1 | 0 | 1 | 0 |
| 0 | 1 | 1 | 0 | 1 |
| 1 | 0 | 0 | 1 | 0 |
| 1 | 0 | 1 | 0 | 1 |
| 1 | 1 | 0 | 0 | 1 |
| 1 | 1 | 1 | 1 | 1 |
</center>

The implementation is actually quite simple, as it directly follows this table.

```ts
type Adder<A, B, C> =
    [A, B, C] extends
    ['0', '0', '0']
  ? {result: '0'; carry: '0'}
  // else if
  : [A, B, C] extends
    ['1', '0', '0'] | ['0', '1', '0'] | ['0', '0', '1']
  ? {result: '1'; carry: '0'}
  // else if
  : [A, B, C] extends
    ['1', '1', '0'] | ['1', '0', '1'] | ['0', '1', '1']
  ? {result: '0'; carry: '1'}
  // else
  : {result: '1'; carry: '1'};
```
```ts
// some tests:
Adder<'0', '0', '0'> // {result: '0', carry: '0'}
Adder<'0', '0', '1'> // {result: '1', carry: '0'}
Adder<'0', '1', '0'> // {result: '1', carry: '0'}
Adder<'0', '1', '1'> // {result: '0', carry: '1'}
Adder<'1', '0', '0'> // {result: '1', carry: '0'}
Adder<'1', '0', '1'> // {result: '0', carry: '1'}
Adder<'1', '1', '0'> // {result: '0', carry: '1'}
Adder<'1', '1', '1'> // {result: '1', carry: '1'}
```

Incredible complexity can arise from a set of simple rules. We can build surprisingly sophisticate systems on top of this adder.

## Full Adder

Quite easily, we can create a Full Adder circuit that adds two 8-bit numbers together. First however, we need to create a couple of utility types.

Recall how we extracted the last character from a string literal type. This way, we can add the two last bits of our two input numbers, and then use the carry to add the two second-to-last bits of our numbers. And so on. 
Our type needs to be thus recursive.

```ts
// this is our FirstCharacter type
type Head<T> = type Head<T> =
  T extends `${infer R}${string}` ? R : never;

// this is different.
// the type returns a string made up of
// all but the first character of the string.
type Tail<T> = 
  T extends `${string}${infer R extends string}`
    ? R extends ''
      ? never
      : R
    : never;

Tail<'abcdef'> // 'bcdef'
```

The algorithm for our recursive `FullAdder<A, B>` type is roughly as follows:
- Given binary string inputs `A` and `B`, if `A` and `B` are single-bit numbers, simply return their sum with no input carry bit, `Adder<A, B, '0'>`
- Otherwise, calculate `FullAdder` for the `Tail`s of `A` and `B` (`ATail` and `BTail`). Using the result and the output carry bit of that, calculate the return value:
- Add the left-most bits of `A` and `B`, as well as the output carry bit of the tail (so, `Adder<Head<A>, Head<B>, TailAdded['carry']>`).
- For the result, concatenate the `result` of the above operation with the `result` of the tail.
- For the carry, simply use the `carry` of the above operation.

Quite convoluted, I know. Or I might just be bad at explaining. Let's just jump into the implementation.

```ts
export type FullAdder<A, B> =
  [Tail<A>, Tail<B>] extends [infer ATail, infer BTail]
    ? [ATail, BTail] extends [never, never]
      // if the tail doesn't exist,
      // we're dealing with a 1-bit number
      ? Adder<A, B, '0'>
      // otherwise, we recursively call FullAdder
      // with the tails of both numberes
      : FullAdder<ATail, BTail>
        // and give it an alias:
        extends infer TailAdded
        // don't worry about this.
        // it is a sort of type assertion
        // so that we can access these fields later
        extends {carry: any; result: any}
      // then, add the left-most bits of A and B
      // along with the carry of the tail
      ? Adder<
          Head<A>,
          Head<B>,
          TailAdded['carry']
        >
        // alias:
        extends infer Current
        // same as above
        extends {carry: any; result: any}
        // finally, the return value:
        ? {
            result:
            `${Current['result']}${TailAdded['result']}`;
            carry: Current['carry'];
          }
        : never
      : never
    : never;
```

VoilÃ ! We have a Full Adder that can handle binary numbers of any length. Let's see it in practice.

```ts
FullAdder<'01', '01'>
  // {result: '10', carry: '0'}

FullAdder<'00100110', '00000010'>
  // {result: '00101000', carry: '0'}

FullAdder<'11111111', '00000001'>
  // {result: '00000000', carry: '1'}
```

The last test in particular shows that we can actually cause overflow! This could be a useful thing to track with flag registers, but in the scope of this project, we won't be adding that complexity.

---

The ability to add two numbers is of course an important operation that the user should be able to perform. It is also however instrumental to how our artificial processor works. For instance, we will need it to increment the Program Counter. With that behind us, we can move on to the more practical parts of the project.

# The parser

In short, we want to transform each Assembly instruction into an object describing that instruction. Conveniently, an instruction is always one line long. The object will contain the instruction type, as well as its operands, be it the register numbers, or immediate (i.e. constant) values.

First things first, let's then define those two operand types.

```ts
export type Register =
  | 'r0'
  | 'r1'
  | 'r2'
  | 'r3'
  | 'r4'
  | 'r5'
  | 'r6'
  | 'r7'
  // the stack pointer
  | 'sp'
  // the link register
  | 'lr'
  // the program counter
  | 'pc';

// simply an alias for string.
// we could theoretically also enforce
// this string to be made up of 8 bits.
// (left as an exercise to the reader)
export type Immediate = string;
```

<Note>
  Apart from eight numbered registers, we also have access to three special registers `sp`, `lr`, and `pc`. You might already be familiar with them. We will revisit those soon&#8482;
</Note>
Probably the simplest instruction to implement is the Move instruction. It has two variants, `MOV (immediate)` and `MOV (register)`, which dictate the type of the second operand.

```ts
// MOV (immediate)
// puts the immediate (constant) value 00010110 in r2
MOV r2, #00010110

// MOV (register)
// copies the value from r1 to r0
MOV r0, r1
```

As you can see, the instruction type is clearly stated at the beginning of the line. This makes parsing extremely easy. However, typically for Assembly dialects, including my dialect, we need to do some more work to figure out the actual variant, be it `MOV (immediate)` or `MOV (register)`.

To make things easier and less bug-prone down the line, let's define the object types for those two instruction variants.

```ts
// MOV Rd, #imm
export type MovImmediateInstr<
  Rd extends Register, imm extends Immediate
> = {
  type: 'MovImmediate';
  // the destination register
  Rd: Rd;
  // the immediate value
  imm: imm;
};

// MOV Rd, Rm
export type MovRegisterInstr<
  Rd extends Register, Rm extends Register
> = {
  type: 'MovRegister';
  Rd: Rd;
  // the 'from' register.
  // value will be copied from Rm to Rd
  Rm: Rm;
};
```

The terms `Rd`, `Rm` (also `Rn`, `Rt`, `Rs`) come from the ARM Assembly grammar. Typically,
- `Rd` stands for `destination register`,
- `Rn` and `Rm` refer to the first and second operation operands (so second and third instruction operands),
- `Rt` is used for instructions dealing with memory, and
- `Rs` stands for `shift amount register`.

---

Onto the parsing. We will define generic types (you can think of them as functions that take types as arguments and return a type) for every instruction and instruction variant.

If we find a match, the function should return the object type, such as a `MovRegisterInstr` type. Otherwise, it should return `never`. This is a clever trick that will let us narrow down on the matching parsing rule without resorting to nested conditional types.

```ts
// T is our instruction string (one line)
// We implement the parsing of our instruction
// with a union of our parser types
type ParseInstr<T> =
  | ParseMovImmediateInstr<T>
  | ParseMovRegisterInstr<T>;

type ParseMovImmediateInstr<T> =
  // parses "MOV " + register + ", #" + immediate
  T extends `MOV ${
    infer Rd extends Register
  }, #${
    infer imm extends Immediate
  }`
    // create the object
    ? MovImmediateInstr<Rd, imm>
    // return never if it's not a match
    : never;

type ParseMovRegisterInstr<T> =
  // parses "MOV " + register + ", " + register
  T extends `MOV ${
    infer Rd extends Register
  }, ${
    infer Rm extends Register
  }`
    ? MovRegisterInstr<Rd, Rm>
    : never;
```

In short, we differentiate between the two instruction with the presence or absence of the `#` character to indicate an immediate value for the second operand.

Let's test these bad boys out.

<Info>
  I will use the `^?` notation to show the final generated type.
</Info>

```ts
ParseInstr<'MOV r3, r4'>
^?  {
      type: 'MovRegister',
      Rd: 'r3',
      Rm: 'r4'
    }

ParseInstr<'MOV r5, #00001000'>
^?  {
      type: 'MovImmediate',
      Rd: 'r5',
      imm: '00001000'
    }

// a non-matching instruction
ParseInstr<'ADD something, bla bla'>
^?  never
```

Perfect! Oh, by the way, if you're wondering about that union pattern in `type ParseInstr<T>`, it works because for this grammar, we should only have one instruction match at all times. Thus, only one parsing type (like `ParseMovRegisterInstr` or maybe `ParseAddImmediateInstr`) will return an object and all the others will return `never`.

This leverages the fact that TypeScript will remove the `never` variants from the union, leaving us with just the generated object.
```ts
type Foo = bar | buzz | never | yeet | never;
     ^?  bar | buzz | yeet;

type Bar = never | 123 | never | never;
     ^?  123
```

### Parsing multiple instructions
Obviously, our program needs to be able to parse more than one instruction at a time.

```ts
ParseProgram<`
  MOV r1, #00001111
  MOV r0, r1
`>
```

We just need a couple of utility types to achieve that. First let's get rid of the surrounding whitespace.

```ts
// trims spaces/newlines from the left side of a string
type TrimLeft<T> = T extends
  `${' ' | '\n'}${infer R}`
    ? TrimLeft<R>
    : T;

// same thing with the right side
type TrimRight<T> = T extends
  `${infer R}${' ' | '\n'}`
  ? TrimRight<R>
  : T;

// trims both sides
type Trim<T> = TrimRight<TrimLeft<T>>;
```

Then let's split our multi-line string into an array of single lines.

```ts
// splits a string based on a separator string
type Split<T, Sep extends string> = T extends
  `${infer Line}${Sep}${infer Rest}`
    ? [Line, ...Split<Rest, Sep>]
    : [T];

// splits a string based on the newline character
type SplitLines<T> = Split<T, '\n'>;
```

Finally, gluing everything together, using [Mapped Types](https://www.typescriptlang.org/docs/handbook/2/mapped-types.html).

```ts
type ParseLine<LineString> =
  ParseInstr<Trim<LineString>>;

type ParseProgram<ProgramString> =
  SplitLines<Trim<ProgramString>> extends infer R
    ? {
        [K in keyof R]: ParseLine<R[K]>
      }
    : never;
```
Big wow, it works ðŸŽ‰.
```ts
ParseProgram<`
  MOV r1, #00001111
  MOV r0, r1
`>
 ^? [
      {
        type: 'MovImmediate',
        Rd: 'r1',
        imm: '00001111',
      },
      {
        type: 'MovRegister',
        Rd: 'r0',
        Rm: 'r1',
      },
    ]
```

### Instruction indices
Our parser could very well just work for a basic assembly format where instructions are executed from top to bottom, always. However, if we want our interpreter to support the Branch instruction, we need to design it around the concept of a Program Counter, which is a special register that stores the index of the current instruction.

<Note>
  a Branch or a Jump instruction tells the processor to continue execution from a different place in the program, instead of the next instruction.
</Note>

Since we're using binary numbers stored in strings, we cannot simply index into the above array. Rather, we have to add the index of each element in binary format into the element itself.

Perhaps surprisingly, we will be using the Full Adder in the parser and not just in the interpreter itself.

Since our `MovImmediateInstr` and `MovRegisterInstr` types don't have an `idx` (index) field, let's create a utility wrapper type to handle that.

```ts
export type Indexed<T, idx extends string> =
  T & {idx: idx};
```

Then to actually index all of our instructions, we create a recursive type that increments the index in binary format on every recursive call.

```ts
type ParseLoop<
  T extends any[],
  // start with index 0
  idx extends string = '00000000'
> =
  // extract the first element, and the rest
  T extends [
    infer Current,
    ...infer Rest,
  ]
    ? [
        // index the first instruction
        Indexed<ParseLine<Current>, idx>,
        // merge the result of the recursively call for
        // the rest of the instructions
        ...ParseLoop<
          Rest,
          // pass the incremented counter
          FullAdder<idx, '00000001'>['result']
        >,
      ]
    // this is our base case.
    // return an empty array if there's nothing left
    : [];

export type ParseProgram<T> =
  SplitLines<Trim<T>> extends infer R extends any[]
    ? ParseLoop<R>
    : never;
```

Now our parsed program will contain this information.

```ts
ParseProgram<`
  MOV r1, #00001111
  MOV r0, r1
`>
 ^? [
      {
        type: 'MovImmediate',
        Rd: 'r1',
        imm: '00001111',
        idx: '00000000',
      },
      {
        type: 'MovRegister',
        Rd: 'r0',
        Rm: 'r1',
        idx: '00000001',
      },
    ]
```

# The interpreter
Our parser is far from being done. But we should already be able to evaluate the `MOV` instruction with an interpreter.

### Registers and memory
As you know, our processor can operate on registers and memory. To evaluate an instruction, we pass our current registers and memory to the evaluating type (similar to our parsing types). After performing the necessary calculations, the type will return the new state of the registers and memory.

Let's define those in a type.

```ts
type Context = {
  registers: {
    r0: string;
    r1: string;
    r2: string;
    r3: string;
    r4: string;
    r5: string;
    r6: string;
    r7: string;
    sp: string;
    lr: string;
    pc: string;
  };
  memory: Record<string, string>;
};
```

Notice that our memory is an object instead of an array. This is because our indices are strings representing binary numbers. It also saves a lot of space, as only the used memory slots will be represented.

### Evaluating one instruction
```ts
EvalInstr<
  ParseInstr<'MOV r0, #00001111'>,
  StartingContext
>;
```

No need to evaluate the whole program at once. Let's see if we can create an interpreter that, given a starting `Context`, can manipulate it. In our case, we will start with `r0 = 00000000`, and we want to end up with `r0 = 00001111`.

We will use that same union pattern we used for the parser.

```ts
type EvalInstr<Instr, Ctx extends Context> =
  | EvalMovImmediateInstr<Instr, Ctx>
  | EvalMovRegisterInstr<Instr, Ctx>;
```

Now, for the hard part. Remember that we want to transform the `Ctx` so that the return value contains our immediate value in `r0`. This means that we will need to overwrite some register and memory values.

There isn't a very easy way to do that in TypeScript, since the intersection operator `&` takes the first value it sees, and we want the opposite behavior. It's time for another utility type.

```ts
type Overwrite<
  A extends Record<string, any>,
  B extends Record<string, any>,
> =
  // simply omit any keys in the first object,
  // which are also present in the second object.
  // then the intersection operator will
  // work as we want it to.
  Omit<A, keyof B> & B;

Overwrite<{r0: '00000000'}, {r0: '00001111'}>;
^?  {
      r0: '00001111' 
    }
```

Finally, the evaluating type.

```ts
type EvalMovImmediateInstr<Instr, Ctx extends Context> = 
  Instr extends MovImmediateInstr<
    infer Rd,
    infer imm
  >
    ? {
        // no changes to memory
        memory: Ctx['memory'];
        registers: Overwrite<
          Ctx['registers'],
          // we use the Record type here
          // since our Rd is dynamic.
          //
          // this is similar to creating an object with
          // a dynamic key using the {[Rd]: imm}
          // notation in JavaScript.
          Record<Rd, imm>
        >;
      }
    // if the `type` field is not a match,
    // return never
    : never;
```

<Idea>
  Notice how those instruction object types we created earlier come in handy now. We can simply infer all the defined fields. TypeScript will determine if the instruction is a match using the `type` field.
</Idea>

Are you still here? Hope this isn't too crazy. The evaluating type for our other variant, `MOV (register)` will be nearly identical.

```ts
type EvalMovRegisterInstr<Instr, Ctx extends Context> =
  Instr extends MovRegisterInstr<
    infer Rd,
    infer Rm
  >
    ? {
        memory: Ctx['memory'];
        registers: Overwrite<
          Ctx['registers'],
          Record<
            Rd,
            // instead of passing it directly,
            // simply take the value from Rm
            Ctx['registers'][Rm]
          >
        >;
      }
    : never;
```

Please work, please work, please work.

```ts
type StartingContext = {
  registers: {
    r0: '00000000';
    // ...
  };
  memory: {};
};

EvalInstr<
  ParseInstr<'MOV r0, #00001111'>,
  StartingContext
>;
^?  {
      registers: {
        r0: '00001111';
      };
      memory: {};
    }
```

We did it ~~gamers~~ coders. Now, onto --

### Evaluating the whole program



---
---
---

```js
// move value from Rn to Rd
MOV Rd, Rn

// move immediate value to Rd
MOV Rd, #00000001

// add values from Rn and Rm and save in Rd
ADD Rd, Rn, Rm

// add value from Rn with an immediate value and save in Rd
ADD Rd, Rn, #00000001

// similarly, other arithmetic and logical operations,
// with register and immediate variants:
SUB Rd, Rn, Rm
SUB Rd, Rn, #00000001
AND Rd, Rn, Rm
AND Rd, Rn, #00000001
OR Rd, Rn, Rm
OR Rd, Rn, #00000001
XOR Rd, Rn, Rm
XOR Rd, Rn, #00000001
NOT Rd, Rn
NOT Rd, #00000001



// push to stack
```

I also wanted the code not to be a complete spaghetti trainwreck. So I laid out the usual parts of the compiler, the lexer, parser, and a tree-walking interpreter. I knew I would need a lot of string manipulation and transformation, so I began writing up some utility functions, such as `Trim` and `Split`

it will even have precedence parsing

For the parser, a classic recursive descent seemed like the perfect choice.

One problem was left-associativity

recursive descent, precedence climbing, recursion instead of while loop, lambda lifting (show original js algo)

incredible complexity can arise from a set of simple rules. In this case, a set of simple features.

`a-b-` is possible because `${string}` matches ``

lang name insom?




error handling is possible

On the topic of programming languages and compiler theory, you might also want to check out The journey of Queso, my programming language.