---
title: 'How to write your own state management library'
createDate: '2022-09-27T22:00:00.000Z'
updateDate: '2022-09-16T18:39:19.991Z'
thumbnail: https://images.unsplash.com/photo-1597600159211-d6c104f408d1?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=2239&q=80
description: 'Ever wondered what magic happens behind the scenes of state management libraries for SPA frameworks? Jump in for a deep dive on selectors, subscribers, transient updates, and more.'
tags:
  - react
  - typescript
  - state
  - state management
  - zustand
  - jotai
  - redux
  - ssr
  - nextjs
  - recoil
---

import {Test} from './Test.tsx';

<Test />
Ever wondered what happens behind the scenes of the most popular state management libraries? How do they re-render only the relevant components instead of the whole tree? How are they different from the Context API?

This article is a deep dive into the inner workings of selectors, subscribers, transient updates, and more. The examples given will be based on the React ecosystem, but if you're coming from a different framework, there are lessons to be learned as well.

---

Let's begin by looking at a popular and simple state management library, [Zustand](https://github.com/pmndrs/zustand).
```tsx
const useUserStore = create((set) => ({
  user: null,
  setUser: user => set({ user }),
  unsetUser: () => set({ user: null }),
}));
```
```tsx
const Profile = () => {
  const user = useUserStore(s => s.user);
  const unsetUser = useUserStore(s => s.unsetUser);

  return <div>
    {user.firstName} {user.lastName}
    <button onClick={unsetUser}>Log out</button>
  </div>;
};
```

The store is defined globally, and yet, only the Profile component will be re-rendered once the user object is modified. This is in contrast to the Context API, where any update will result in the whole sub-tree -- starting from the Context Provider -- being re-rendered.

INSERT INTERACTIVE COMPONENT HERE

The mechanisms behind this are selectors and subscribers. We will examine those closely in our implementation.

First, however, let's design a simple API for our own state management library. Similar to Zustand and dissimilar to say Jotai, we will have stores that can contain multiple state values. For good TypeScript support, we will split the store into state and actions, i.e. methods that modify the state.

```tsx
const counterStore = create(
  {
    counter: 0,
  },
  set => ({
    setCounter: counter => set({ counter }),
    increment: () => set(state => ({
      counter: state.counter + 1,
    })),
  }),
);
```
```tsx
const Counter = () => {
  const counter = useSelector(
    counterStore,
    s => s.counter
  );

  return <button onClick={counterStore.increment}>
    {counter}
  </button>;
};
```

We then start working backward to implement this API. But how do we actually proceed? First, we need to understand what goes on behind the scenes.

## Subscribers
This design pattern is often called the Observer pattern. A typical state management library uses it to broadcast changes in the store to the store's subscribers. The subscribers are also often called listeners instead. Queue my contrived analogy&nbsp;---

Imagine a **swarm of drones** following the **leader**. The leader receives information from mission control, such as the destination and velocity. To make it even more advanced, mission control can at any time assign more drones to the swarm. In case of any changes to said destination and velocity, the whole swarm must receive the new information.

One solution is for the drones to poll the leader, i.e. frequently ask if there have been any changes. As you can imagine, this is not very efficient. We could flip this scenario around. The drones can simply notify the leader that they have joined (or left) the swarm and that they expect the leader to **notify** them about any new information coming from mission control.

*Please*, don't mind my analogy-making skills. Let's jump into the code for this example:
```tsx
const createLeader = () => {
  let info = {
    destination: 'north',
    velocity: 10,
  };

  // drones are just callback functions
  // which we will invoke with the new data
  // whenever it changes
  type Drone = (info: typeof info) => void;

  const drones: Drone[] = [];

  // add a drone to the drones array
  const joinSwarm = (drone: Drone) =>
    drones.push(drone);

  // remove a drone from the drones array
  const leaveSwarm = (drone: Drone) =>
    drones.splice(drones.indexOf(drone), 1);

  // mission control uses this to make the leader
  // and subsequently the swarm aware of new information
  const notify = (newInfo: typeof info) => {
    info = newInfo;

    for (const drone of drones) {
      drone(info);
    };
  };

  return {joinSwarm, leaveSwarm, notify};
};
```
```tsx
const leader = createLeader();

leader.joinSwarm(newInfo =>
  console.log('Drone A:', newInfo));
leader.joinSwarm(newInfo =>
  console.log('Drone B:', newInfo));

leader.notify({ direction: 'west', velocity: 5 });
// prints:
// Drone A: { direction: 'west', velocity: 5 }
// Drone B: { direction: 'west', velocity: 5 }
```

In essence, just like with event emitters and listeners, you register a subscriber, which then gets called when the event (here, a state change) is fired. Below we will transform this analogy into a concrete implementation.

## Selectors
A selector defines which part of the state the given component should subscribe to. Additionally, the selector might define a value that's derived from the state instead. In other words, the subscriber should be invoked *only when* the selected value has been changed. 

We could imagine a special drone that adjusts its own velocity based on environmental factors, and not mission control's command. Thus, this drone only cares about changes in direction. Sending the changes in velocity would simply be inefficient.

```tsx
const leader = () => {
  let info = {
    destination: 'north',
    velocity: 10,
  };

  // A selector is commonly a function that
  // when given the whole state,
  // returns just the part it cares about
  // Here, we simplify it so that the subscriber only
  // specifies the key of the state they want to select
  type Selector = keyof typeof info;

  // the drones now also contain the selector
  type Drone = [
    selector: Selector,
    callback: val => void,
  ];
  const drones: Drone[] = [];

  const joinSwarm = (
    selector: Selector,
    callback: Drone,
  ) => drones.push(drone);

  const leaveSwarm = (drone: Drone) =>
    drones.splice(drones.indexOf(drone), 1);

  const notify = (newInfo: typeof info) => {
    for (const [selector, callback] of drones) {
      // check if direction has changed since
      // the last `notify` call
      // if so, notify all drones
      // with the 'direction' selector 
      if (
        info.direction !== newInfo.direction
        && selector === 'direction'
      ) {
        callback(newInfo.direction);
      }
      // check if velocity has changed since
      // the last `notify` call
      // if so, notify all drones
      // with the 'velocity' selector
      else if (
        info.velocity !== newInfo.velocity
        && selector === 'velocity'
      ) {
        callback(newInfo.velocity);
      }
    }

    info = newInfo;
  };

  return {joinSwarm, leaveSwarm, notify};
};
```
```tsx
leader.joinSwarm('direction', direction =>
  console.log('Drone A changed direction:', direction));
leader.joinSwarm('velocity', velocity =>
  console.log('Drone B changed velocity:', velocity));

// changing direction, but not velocity
leader.notify({ direction: 'south', velocity: 10 });
// Drone A changed direction: south

// changing velocity, but not direction
leader.notify({ direction: 'south', velocity: 20 });
// Drone B changed velocity: 20

// changing direction and velocity
leader.notify({ direction: 'west', velocity: 5 });
// Drone A changed direction: south
// Drone B changed velocity: 20
```

In practice, this would look very different, since selectors commonly allow any value to be returned. We won't have to implement that part, however, as we can use the built-in React equality checking.

## Transient updates
...are what makes modern state management libraries efficient. To understand it better, let's first see an example with the Context API

```tsx
const CounterContext = createContext<{
  counter: number;
  increment: () => void;
}>(null!);

const Child = () => {
  const {counter, increment} =
    useContext(CounterContext);

  return <button onClick={increment}>
    {counter}
  </button>
}

const Parent = () => {
  const [counter, setCounter] = 
  return <CounterContext.Provider
    value={{
      counter,
      increment: () => setCounter(x => x + 1),
    }}
  >
    <Child />
  </CounterContext.Provider>
}
```

To be able to modify the state from a descendant of the component that defines it, we pass the state setter that we get from `useState` into the context. When we call that setter from within that descendant, it's the parent component's state that gets updated, which triggers all its children to re-render as well -- *unless they are Memo'ed*.

In comparison, transient updates allow us to re-render the exact component that subscribed to the state using a selector. For React, this is done by combining `useState` with the `subscriber` pattern.

INTERACTIVE COMPONENT HERE

---

Now that we have the backbone of required knowledge, let's jump into --

## The implementation

We can now translate my bad drone analogy into real application code.

```tsx
const create = <STATE, ACTIONS>(
  initialState: STATE,
  actions: (set: () => 
    // either return a partial state:
    | Partial<STATE>
    // or a setState-like callback for derived values:
    | (current: STATE) => Partial<STATE>
  ) => ACTIONS
) => {
  // initialize the state with the user-defined defaults
  let state = initialState;

  // pass the setState function to the actions.
  // basically your usual React setState,
  // with the addition of merging the state,
  // like in Zustand
  actions = actions((setStateAction) => {
    const newVal = 
      typeof setStateAction === 'function'
        ? setStateAction(state)
        : setStateAction;
    
    notify({...info, ...newVal});
  })

  type Subscriber = (state: STATE) => void;

  // we can remove the selector code here
  // and move it to the implementation of useSelector.
  const subscribers: Subscriber[] = [];

  const subscribe = (
    subscriber: Subscriber,
  ) => {
    subscribers.push(subscriber);

    // instead of an unsubscribe method,
    // we use the common pattern of returning
    // a cleanup function,
    // which is the unsubscribe method
    return () =>
      subscribers.splice(subscriber.indexOf(drone), 1);
  }

  // we don't expose (return) this function
  // directly anymore
  // instead, we will expose the user-defined
  // actions only 
  const notify = (newState: STATE) => {
    for (const subscriber of subscribers) {
      // again, we don't care about selectors here
      subscriber(newState);
    }

    state = newState;
  };

  return {state, subscribe, ...actions};
};
```

This implementation could be -- at a high level -- how major state management libraries implement their stores for the vanilla JS portion of their library. Next, we will go framework-specific and implement the `useSelector` hook. This is where the magic happens. Or rather, you will see there's not much magic involved. We simply update a `useState` whenever the store's state changes using a store subscriber.

```tsx
// we use the type of the state parameter
// of the subscribe method defined in the last code block
// to define our STATE type
const useSelector = <STATE>(
  store: {subscribe: (state: STATE) => void},
  selector: STATE => any,
) => {
  // we use the current state value to set the
  // initial value for our state
  const [selectedValue, setSelectedValue]
    = useState(selector(state))

  useEffect(() => {
    // if the return part is confusing to you,
    // double back to the previous code block
    // to see that calling the subscribe method
    // returns the unsubscribe method,
    // which lets us use this convenient pattern
    return store.subscribe(newState => {
      // React will take care of handling
      // equality checks, making sure
      // this setState only triggers a re-render
      // when necessary
      setSelectedValue(
        selector(newState);
      );
    });
  }, []);

  return selectedValue;
}
```

That's just it. In fact, there are more comments here than actual code! 

---
### Addendum
Keep in mind this high-level overview only scratches the surface of the actual implementation. In reality, without proper optimizations and strategies, this implementation in and of itself can lead to surprising behavior when combined with JS frameworks.

I encourage you to dive deep into codebases of projects such as Zustand and Jotai to learn more.