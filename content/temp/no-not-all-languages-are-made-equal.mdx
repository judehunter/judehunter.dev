---
title: 'No, not all programming languages are made equal'
createDate: '2022-09-16T18:39:19.991Z'
updateDate: '2022-09-16T18:39:19.991Z'
thumbnail: https://images.unsplash.com/photo-1508507110059-a4b6a4013eb7?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&fit=crop&w=1470&q=80
description: 'The story of how my dream programming language has evolved over the years, from a C# tree-walking interpreter, to a WebAssembly compiled language.'
tags:
  - discussion
  - programming
  - argument
  - proglang
  - queso
  - bytecode
  - interpreter
---

> Programming languages have their niches and can't be compared. You just need to pick the right tool for the job.

While picking the right tool for the job is an important part of software engineering, this argument is often used as a way to stop any constructive criticism about the capabilities and design choices behind programming languages, citing elitism. It suggests that all languages are equally suited for the tasks in their own niches.

Just like any other human-made tools, all programming languages have flaws rooted in the lack of a knowledge backbone, foresight, and prior experimentation. More generally, many design choices simply do not stand the test of time, which we can only observe in hindsight. Many of them we even wish to change, but can't due to backward compatibility.

I argue this is the driving force of innovation. Ecosystems are built on top of others. They bring their own flaws but are nevertheless built to be an improvement. It is the flaws of existing languages that help new solutions to be better.

Understandably, due to human nature, we tend to get confrontational about these things. However, for our own benefit, we should be able to point out these limitations and compare programming languages as a whole.

Is COBOL really safe from criticism?

Most mainstream languages are indeed universally used in a variety of scenarios, making them general-purpose languages. Case in point, this allows us to compare many of their general, niche-agnostic features.

TypeScript was created to fill the need of static typing in JavaScript, especially for bigger projects. Yes, pick the right tool for your job. JavaScript might be the better choice for smaller projects. Surely though, arguing the benefits of type correctness and compile-time bug detection of Typescript shouldn't be met with a prompt dismissal.

These arguments can be more than a subjective opinion. The experience and collective opinions of the developer community allow us to reason about which features are likely more suited to the majority of general use cases. We can discuss such aspects as developer experience, ease of use, flexibility, extendability, and just plain usefulness of certain design choices behind our tools.

The fact that mainstream languages are all... mainstream doesn't make them equal or otherwise immune to criticism. We should differentiate between popularity and quality. While they often do go in tandem, other factors such as hype and trendiness can make less qualified languages more popular.

Why should it be that we mustn't use the scientific method to reason about the fitness of our tools? We can and should compare languages *generally* and not only in the context of a particular problem.

> All languages are bad. Some are just 